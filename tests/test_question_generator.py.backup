"""
Tests para QuestionGenerator.

Valida generación de preguntas contextuales basadas en gap analysis.
"""
import pytest
from unittest.mock import Mock, patch
from typing import List

from src.question_generator import (
    QuestionGenerator,
    Question,
    QuestionGroup,
    Language
)
from src.gap_analyzer import GapAnalysisResult, SkillGap
from src.job_analyzer import RequirementPriority, Skill, SkillCategory, JobRequirements
from src.cv_parser import CVData
from src.ai_backend import GeminiClient


# Fixtures

@pytest.fixture
def mock_ai_client():
    """Mock del cliente Gemini AI."""
    client = Mock(spec=GeminiClient)
    client.generate_content = Mock(return_value="""1. La vacante requiere Docker pero no lo veo en tu CV. ¿Tienes experiencia con Docker? Si es así, describe brevemente cómo lo has usado.
2. Esta posición requiere Kubernetes. ¿Has trabajado con Kubernetes? Describe un proyecto donde lo hayas usado.
3. Se menciona AWS como requisito importante. ¿Cuál es tu nivel de experiencia con AWS?""")
    return client


@pytest.fixture
def sample_cv_data():
    """CV de ejemplo."""
    cv_text = """John Doe
Email: john@example.com
Phone: 123-456-7890

Summary: Software developer with 3 years experience

Technical Skills:
- Python
- JavaScript

Work Experience:
Developer at Tech Corp (2020-2023)
Developed web applications

Education:
BS Computer Science, MIT (2020)
"""
    
    # Crear CVData que simula tener skills y experience
    cv_data = CVData(
        raw_text=cv_text,
        sections={
            "summary": "Software developer with 3 years experience",
            "skills": "Python, JavaScript",
            "experience": "Developer at Tech Corp (2020-2023)",
            "education": "BS Computer Science, MIT (2020)"
        },
        metadata={"format": "text"}
    )
    
    # Añadir atributos adicionales para compatibilidad
    cv_data.technical_skills = [
        Skill(name="Python", category=SkillCategory.TECHNICAL, priority=RequirementPriority.MUST_HAVE),
        Skill(name="JavaScript", category=SkillCategory.TECHNICAL, priority=RequirementPriority.MUST_HAVE)
    ]
    cv_data.work_experience = [{"title": "Developer", "company": "Tech Corp", "duration": "2020-2023"}]
    cv_data.education = [{"degree": "BS Computer Science", "institution": "MIT", "year": "2020"}]
    
    return cv_data


@pytest.fixture
def sample_job_requirements():
    """Requisitos de vacante de ejemplo."""
    return JobRequirements(
        title="Senior Python Developer",
        company="Tech Inc",
        location="Remote",
        technical_skills=[
            Skill(name="Python", category=SkillCategory.TECHNICAL, priority=RequirementPriority.MUST_HAVE),
            Skill(name="Docker", category=SkillCategory.TECHNICAL, priority=RequirementPriority.MUST_HAVE),
            Skill(name="Kubernetes", category=SkillCategory.TECHNICAL, priority=RequirementPriority.NICE_TO_HAVE),
            Skill(name="AWS", category=SkillCategory.TECHNICAL, priority=RequirementPriority.MUST_HAVE)
        ],
        soft_skills=[
            Skill(name="Leadership", category=SkillCategory.SOFT, priority=RequirementPriority.NICE_TO_HAVE)
        ],
        years_of_experience=5,
        languages=[]
    )


@pytest.fixture
def sample_gaps():
    """Lista de gaps de ejemplo."""
    return [
        SkillGap(
            skill_name="Docker",
            priority=RequirementPriority.MUST_HAVE,
            context="Container orchestration",
            found_in_cv=False
        ),
        SkillGap(
            skill_name="Kubernetes",
            priority=RequirementPriority.NICE_TO_HAVE,
            context="Cloud deployment",
            found_in_cv=False
        ),
        SkillGap(
            skill_name="AWS",
            priority=RequirementPriority.MUST_HAVE,
            context="Cloud platform",
            found_in_cv=False
        )
    ]


@pytest.fixture
def sample_gap_analysis(sample_cv_data, sample_job_requirements, sample_gaps):
    """GapAnalysisResult de ejemplo."""
    gap_analysis = GapAnalysisResult(
        cv_data=sample_cv_data,
        job_requirements=sample_job_requirements
    )
    
    # Añadir gaps técnicos
    gap_analysis.technical_gaps = sample_gaps
    gap_analysis.experience_gap = 2  # Faltan 2 años
    gap_analysis.match_score = 60.0
    
    return gap_analysis


# Tests de Inicialización

def test_question_generator_initialization():
    """Test: inicialización básica."""
    generator = QuestionGenerator()
    
    assert generator.language == Language.SPANISH
    assert generator.ai_client is None
    assert generator.templates is not None


def test_question_generator_with_ai_client(mock_ai_client):
    """Test: inicialización con AI client."""
    generator = QuestionGenerator(ai_client=mock_ai_client)
    
    assert generator.ai_client == mock_ai_client
    assert generator.language == Language.SPANISH


def test_question_generator_with_different_language():
    """Test: inicialización con idioma diferente."""
    generator = QuestionGenerator(language=Language.ENGLISH)
    
    assert generator.language == Language.ENGLISH
    assert "requires" in generator.templates["technical"].lower()


# Tests de Generación de Preguntas (Templates)

def test_generate_template_questions_basic(sample_gap_analysis):
    """Test: generación básica de preguntas con templates."""
    generator = QuestionGenerator()
    
    questions = generator.generate_questions(
        sample_gap_analysis,
        max_questions=3,
        use_ai=False
    )
    
    assert len(questions) <= 3
    assert all(isinstance(q, Question) for q in questions)
    assert all(q.text for q in questions)


def test_generate_template_questions_prioritize_critical(sample_gap_analysis):
    """Test: priorización de gaps críticos."""
    generator = QuestionGenerator()
    
    questions = generator.generate_questions(
        sample_gap_analysis,
        max_questions=5,
        prioritize_critical=True,
        use_ai=False
    )
    
    # Las primeras preguntas deben ser sobre must-haves
    if questions:
        first_question = questions[0]
        assert first_question.priority == RequirementPriority.MUST_HAVE


def test_generate_questions_respects_max_limit(sample_gap_analysis):
    """Test: respeta el límite máximo de preguntas."""
    generator = QuestionGenerator()
    
    questions = generator.generate_questions(
        sample_gap_analysis,
        max_questions=2,
        use_ai=False
    )
    
    assert len(questions) <= 2


def test_generate_questions_empty_gaps():
    """Test: manejo de gap analysis sin gaps."""
    generator = QuestionGenerator()
    
    # Gap analysis vacío
    empty_gap_analysis = GapAnalysisResult(
        cv_data=CVData(raw_text="Test CV", sections={}, metadata={}),
        job_requirements=JobRequirements(title="Job", company="Company", location="Remote")
    )
    
    questions = generator.generate_questions(
        empty_gap_analysis,
        max_questions=5,
        use_ai=False
    )
    
    # Debe retornar lista vacía o muy pequeña
    assert isinstance(questions, list)


# Tests de Generación con IA

def test_generate_ai_questions(mock_ai_client, sample_gap_analysis):
    """Test: generación de preguntas con IA."""
    generator = QuestionGenerator(ai_client=mock_ai_client)
    
    questions = generator.generate_questions(
        sample_gap_analysis,
        max_questions=3,
        use_ai=True
    )
    
    assert len(questions) > 0
    assert mock_ai_client.generate_content.called
    assert all(isinstance(q, Question) for q in questions)


def test_generate_ai_questions_fallback_on_error(sample_gap_analysis):
    """Test: fallback a templates si falla IA."""
    # AI client que lanza excepción
    failing_client = Mock(spec=GeminiClient)
    failing_client.generate_content = Mock(side_effect=Exception("API Error"))
    
    generator = QuestionGenerator(ai_client=failing_client)
    
    questions = generator.generate_questions(
        sample_gap_analysis,
        max_questions=3,
        use_ai=True
    )
    
    # Debe usar templates como fallback
    assert len(questions) > 0


def test_generate_questions_no_ai_client(sample_gap_analysis):
    """Test: generación sin AI client usa templates."""
    generator = QuestionGenerator()  # Sin AI client
    
    questions = generator.generate_questions(
        sample_gap_analysis,
        max_questions=3,
        use_ai=True  # Intenta usar IA pero no hay cliente
    )
    
    # Debe usar templates
    assert len(questions) > 0


# Tests de Agrupación

def test_group_questions_by_category(sample_gap_analysis):
    """Test: agrupación de preguntas por categoría."""
    generator = QuestionGenerator()
    
    questions = generator.generate_questions(
        sample_gap_analysis,
        max_questions=5,
        use_ai=False
    )
    
    groups = generator.group_questions(questions)
    
    assert isinstance(groups, list)
    assert all(isinstance(g, QuestionGroup) for g in groups)


def test_question_groups_have_intro_text(sample_gap_analysis):
    """Test: grupos tienen texto de introducción."""
    generator = QuestionGenerator()
    
    questions = generator.generate_questions(
        sample_gap_analysis,
        max_questions=5,
        use_ai=False
    )
    
    groups = generator.group_questions(questions)
    
    if groups:
        # Al menos un grupo debe tener intro
        assert any(g.intro_text for g in groups)


def test_groups_sorted_by_priority(sample_gap_analysis):
    """Test: grupos ordenados por prioridad."""
    generator = QuestionGenerator()
    
    questions = generator.generate_questions(
        sample_gap_analysis,
        max_questions=5,
        use_ai=False
    )
    
    groups = generator.group_questions(questions)
    
    # Grupos con must-haves deben aparecer primero
    if len(groups) > 1:
        first_group_score = groups[0].get_priority_score()
        second_group_score = groups[1].get_priority_score()
        assert first_group_score >= second_group_score


# Tests de Multi-idioma

def test_spanish_questions(sample_gap_analysis):
    """Test: preguntas en español."""
    generator = QuestionGenerator(language=Language.SPANISH)
    
    questions = generator.generate_questions(
        sample_gap_analysis,
        max_questions=2,
        use_ai=False
    )
    
    if questions:
        # Debe contener palabras en español
        first_question = questions[0].text.lower()
        assert any(word in first_question for word in ["requiere", "vacante", "experiencia"])


def test_english_questions(sample_gap_analysis):
    """Test: preguntas en inglés."""
    generator = QuestionGenerator(language=Language.ENGLISH)
    
    questions = generator.generate_questions(
        sample_gap_analysis,
        max_questions=2,
        use_ai=False
    )
    
    if questions:
        # Debe contener palabras en inglés
        first_question = questions[0].text.lower()
        assert any(word in first_question for word in ["requires", "position", "experience"])


def test_portuguese_questions(sample_gap_analysis):
    """Test: preguntas en portugués."""
    generator = QuestionGenerator(language=Language.PORTUGUESE)
    
    questions = generator.generate_questions(
        sample_gap_analysis,
        max_questions=2,
        use_ai=False
    )
    
    if questions:
        first_question = questions[0].text.lower()
        assert any(word in first_question for word in ["requer", "vaga", "experiência"])


def test_french_questions(sample_gap_analysis):
    """Test: preguntas en francés."""
    generator = QuestionGenerator(language=Language.FRENCH)
    
    questions = generator.generate_questions(
        sample_gap_analysis,
        max_questions=2,
        use_ai=False
    )
    
    if questions:
        first_question = questions[0].text.lower()
        assert any(word in first_question for word in ["nécessite", "poste", "expérience"])


def test_set_language_changes_templates(sample_gap_analysis):
    """Test: cambiar idioma actualiza templates."""
    generator = QuestionGenerator(language=Language.SPANISH)
    
    # Generar en español
    questions_es = generator.generate_questions(sample_gap_analysis, max_questions=1, use_ai=False)
    
    # Cambiar a inglés
    generator.set_language(Language.ENGLISH)
    questions_en = generator.generate_questions(sample_gap_analysis, max_questions=1, use_ai=False)
    
    if questions_es and questions_en:
        assert questions_es[0].text != questions_en[0].text


# Tests de Categorización

def test_categorize_technical_skills():
    """Test: categorización de skills técnicas."""
    generator = QuestionGenerator()
    
    gap = SkillGap(
        skill_name="Docker",
        priority=RequirementPriority.MUST_HAVE,
        found_in_cv=False
    )
    
    category = generator._get_gap_category(gap)
    assert category == "technical"


def test_categorize_language_skills():
    """Test: categorización de idiomas."""
    generator = QuestionGenerator()
    
    gap = SkillGap(
        skill_name="English",
        priority=RequirementPriority.MUST_HAVE,
        found_in_cv=False
    )
    
    category = generator._get_gap_category(gap)
    assert category == "language"


def test_categorize_certifications():
    """Test: categorización de certificaciones."""
    generator = QuestionGenerator()
    
    gap = SkillGap(
        skill_name="AWS Certified",
        priority=RequirementPriority.NICE_TO_HAVE,
        found_in_cv=False
    )
    
    category = generator._get_gap_category(gap)
    assert category == "certification"


def test_categorize_soft_skills():
    """Test: categorización de soft skills."""
    generator = QuestionGenerator()
    
    gap = SkillGap(
        skill_name="Leadership",
        priority=RequirementPriority.NICE_TO_HAVE,
        found_in_cv=False
    )
    
    category = generator._get_gap_category(gap)
    assert category == "soft_skill"


# Tests de Question y QuestionGroup

def test_question_is_critical():
    """Test: detección de preguntas críticas."""
    gap = SkillGap(
        skill_name="Docker",
        priority=RequirementPriority.MUST_HAVE,
        found_in_cv=False
    )
    
    question = Question(
        text="Test question",
        gap=gap,
        category="technical",
        priority=RequirementPriority.MUST_HAVE
    )
    
    assert question.is_critical()


def test_question_not_critical():
    """Test: pregunta no crítica."""
    gap = SkillGap(
        skill_name="Kubernetes",
        priority=RequirementPriority.NICE_TO_HAVE,
        found_in_cv=False
    )
    
    question = Question(
        text="Test question",
        gap=gap,
        category="technical",
        priority=RequirementPriority.NICE_TO_HAVE
    )
    
    assert not question.is_critical()


def test_question_group_add_question():
    """Test: añadir pregunta a grupo."""
    group = QuestionGroup(category="technical")
    
    gap = SkillGap(skill_name="Docker", priority=RequirementPriority.MUST_HAVE, found_in_cv=False)
    question = Question(
        text="Test",
        gap=gap,
        category="technical",
        priority=RequirementPriority.MUST_HAVE
    )
    
    group.add_question(question)
    
    assert len(group.questions) == 1
    assert group.questions[0] == question


def test_question_group_priority_score():
    """Test: cálculo de score de prioridad del grupo."""
    group = QuestionGroup(category="technical")
    
    # Añadir pregunta must-have (vale 10)
    gap1 = SkillGap(skill_name="Docker", priority=RequirementPriority.MUST_HAVE, found_in_cv=False)
    q1 = Question(text="Q1", gap=gap1, category="technical", priority=RequirementPriority.MUST_HAVE)
    group.add_question(q1)
    
    # Añadir pregunta nice-to-have (vale 5)
    gap2 = SkillGap(skill_name="K8s", priority=RequirementPriority.NICE_TO_HAVE, found_in_cv=False)
    q2 = Question(text="Q2", gap=gap2, category="technical", priority=RequirementPriority.NICE_TO_HAVE)
    group.add_question(q2)
    
    # Score total: 10 + 5 = 15
    assert group.get_priority_score() == 15


# Tests de Experience Gap

def test_generate_experience_question(sample_gap_analysis):
    """Test: generación de pregunta sobre gap de experiencia."""
    generator = QuestionGenerator()
    
    exp_question = generator._create_experience_question(sample_gap_analysis)
    
    assert exp_question is not None
    assert exp_question.category == "experience"
    assert "experiencia" in exp_question.text.lower()


def test_no_experience_question_when_no_gap():
    """Test: no genera pregunta de experiencia si no hay gap."""
    generator = QuestionGenerator()
    
    # Gap analysis sin gap de experiencia
    gap_analysis = GapAnalysisResult(
        cv_data=CVData(raw_text="Test", sections={}, metadata={}),
        job_requirements=JobRequirements(title="Job", company="Company", location="Remote")
    )
    gap_analysis.experience_gap = 0
    
    exp_question = generator._create_experience_question(gap_analysis)
    
    assert exp_question is None


# Tests de Prompt Building (AI)

def test_build_ai_prompt_structure(sample_gap_analysis):
    """Test: estructura del prompt para IA."""
    generator = QuestionGenerator()
    
    gaps_summary = generator._prepare_gaps_summary(sample_gap_analysis)
    cv_summary = generator._prepare_cv_summary(sample_gap_analysis.cv_data)
    job_summary = generator._prepare_job_summary(sample_gap_analysis.job_requirements)
    
    prompt = generator._build_ai_prompt(
        gaps_summary=gaps_summary,
        cv_summary=cv_summary,
        job_summary=job_summary,
        max_questions=3
    )
    
    assert "estratega de carrera" in prompt.lower()
    assert "preguntas" in prompt.lower()
    assert str(3) in prompt


def test_prepare_gaps_summary_identifies_critical(sample_gap_analysis):
    """Test: resumen de gaps identifica críticos."""
    generator = QuestionGenerator()
    
    summary = generator._prepare_gaps_summary(sample_gap_analysis)
    
    assert "críticos" in summary.lower() or "must-have" in summary.lower()


def test_prepare_cv_summary_includes_skills(sample_cv_data):
    """Test: resumen de CV incluye skills."""
    generator = QuestionGenerator()
    
    summary = generator._prepare_cv_summary(sample_cv_data)
    
    assert "skills" in summary.lower() or "habilidades" in summary.lower()


def test_prepare_job_summary_includes_requirements(sample_job_requirements):
    """Test: resumen de vacante incluye requisitos."""
    generator = QuestionGenerator()
    
    summary = generator._prepare_job_summary(sample_job_requirements)
    
    assert "must-have" in summary.lower() or len(summary) > 0


# Tests de Parsing de Respuesta AI

def test_parse_ai_response_numbered_list(sample_gaps):
    """Test: parsea respuesta de IA con lista numerada."""
    generator = QuestionGenerator()
    
    # Crear gap analysis mock
    gap_analysis = GapAnalysisResult(
        cv_data=CVData(raw_text="Test", sections={}, metadata={}),
        job_requirements=JobRequirements(title="Job", company="Company", location="Remote")
    )
    gap_analysis.technical_gaps = sample_gaps
    
    ai_response = """1. ¿Tienes experiencia con Docker?
2. ¿Has trabajado con Kubernetes?
3. ¿Cuál es tu nivel con AWS?"""
    
    questions = generator._parse_ai_response(ai_response, gap_analysis)
    
    assert len(questions) == 3
    assert all(isinstance(q, Question) for q in questions)


def test_parse_ai_response_dashed_list(sample_gaps):
    """Test: parsea respuesta de IA con lista con guiones."""
    generator = QuestionGenerator()
    
    gap_analysis = GapAnalysisResult(
        cv_data=CVData(raw_text="Test", sections={}, metadata={}),
        job_requirements=JobRequirements(title="Job", company="Company", location="Remote")
    )
    gap_analysis.technical_gaps = sample_gaps
    
    ai_response = """- ¿Tienes experiencia con Docker?
- ¿Has trabajado con Kubernetes?"""
    
    questions = generator._parse_ai_response(ai_response, gap_analysis)
    
    assert len(questions) > 0


def test_parse_ai_response_empty():
    """Test: parsea respuesta vacía de IA."""
    generator = QuestionGenerator()
    
    gap_analysis = GapAnalysisResult(
        cv_data=CVData(raw_text="Test", sections={}, metadata={}),
        job_requirements=JobRequirements(title="Job", company="Company", location="Remote")
    )
    
    questions = generator._parse_ai_response("", gap_analysis)
    
    assert isinstance(questions, list)
    assert len(questions) == 0
